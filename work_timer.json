[
  {
    "role": "system",
    "content": "You are a helpful coding assistant. Your code snippets must never contain ellipses, or any comment meant to represent code. "
  },
  {
    "role": "user",
    "content": "I want to make a scheduling utility for my iPhone that automatically sets alarms for 30 minutes before my work shifts on the proper day. I get my schedule 1 week in advance, and it has me starting and ending at different times each day. It's pretty much random what time I go into work on any given day, so I need this utility to help me keep track of it. What is your suggested tech stack?"
  },
  {
    "role": "assistant",
    "content": "### Best “iPhone-first” approach: **Apple Shortcuts + Calendar (no custom app)**\nIf your goal is reliability with minimal maintenance, the strongest stack is:\n\n- **Input**: Your weekly schedule in **Calendar** (manually entered, imported .ics, or pasted)\n- **Automation engine**: **Apple Shortcuts** (Personal Automation + scheduled runs)\n- **Alarm creation**: Shortcuts action **Create Alarm** (Clock app) or **Add Reminder** (fallback)\n\n**Why this is best**\n- No App Store build, no backend, no permissions headaches.\n- Works entirely on-device.\n- Shortcuts can read calendar events and create alarms relative to start time.\n\n**Limitation to be aware of**\n- iOS automations can be restricted in how “automatic” they are depending on trigger type; a daily scheduled shortcut generally works well, but some configurations may ask for confirmation. If you need 100% hands-off behavior, see the native app option below.\n\n---\n\n### Best “fully automatic + polished” approach: **Native iOS app**\nIf you want a true utility that runs quietly and reliably:\n\n#### Tech stack\n- **Language/UI**: **Swift + SwiftUI**\n- **Data**: **EventKit** (read shifts from Apple Calendar) or your own local store using **SwiftData** (iOS 17+) / **Core Data**\n- **Notifications**: **UserNotifications** framework (schedule local notifications 30 minutes before)\n- **Optional schedule import**:\n  - **.ics parsing**: use EventKit import flows or parse with a Swift library\n  - If schedule is copied text/email: add a **Share Extension** to ingest it\n\n**Important iOS reality**\n- Third-party apps generally **cannot create Clock app alarms** directly. The reliable way is to schedule **local notifications**, which behave like alarms (sound + banner), and can be made persistent if you configure them well.\n- For guaranteed alerting, you’ll rely on **notification permissions**, and optionally “Critical Alerts” (rarely approved by Apple, usually medical/safety).\n\n---\n\n### If your schedule lives online (When I Work, Homebase, etc.)\nThen the best stack is:\n\n- **iOS app**: Swift/SwiftUI\n- **Integration**: Their API (if available) or **Calendar subscription** feed\n- **Server (optional)**: lightweight **Cloudflare Workers / AWS Lambda** to normalize schedules\n- **Sync**: push to Calendar or send structured data to the app\n- **Alerting**: local notifications on-device (still best)\n\n---\n\n## My recommendation\n- If you’re okay with a “power user” solution: **Shortcuts + Calendar** is the fastest and easiest.\n- If you want it to feel like a real product and be dependable: **SwiftUI app + EventKit + UserNotifications** (notifications, not Clock alarms).\n\n---\n\n## Two quick questions to lock the stack in\n1. Do you receive the schedule as **a calendar invite / .ics**, **a screenshot/photo**, **a PDF**, or **plain text**?\n2. Do you specifically need **Clock app alarms**, or are **push-style local notifications** acceptable (with sound and lock-screen alert)?"
  },
  {
    "role": "user",
    "content": "Let's use shortcuts. I have a Mac I could use to help. Would it be possible to autogenerate the ics file from a PDF or text file?"
  },
  {
    "role": "assistant",
    "content": "Yes. The most reliable setup is:\n\n1) Convert your schedule (PDF or text) into a structured table of shifts (date, start, end, title, location).\n2) Generate an `.ics` calendar file from that structure on your Mac.\n3) Import/subscribe to that calendar on iPhone.\n4) Use a Shortcut that runs daily and creates alarms 30 minutes before each shift.\n\nBelow are practical stacks for (1)–(2), depending on what your source looks like.\n\n## Option A (best if it’s selectable text in the PDF): Python on Mac → `.ics`\n**Tech stack**\n- Python 3 (macOS already supports installing via Homebrew)\n- `pdfplumber` (extract text/tables)\n- `icalendar` (write `.ics`)\n- Optionally `dateparser` (flexible date parsing)\n\n**Pros:** Very automatable, accurate if the PDF has real text.  \n**Cons:** Harder if the PDF is a scanned image.\n\n## Option B (best if schedule is already text): Script → `.ics`\nIf you can get the schedule as plain text (email, copied from app/website), this is straightforward:\n- Python or Node.js\n- Regex + `icalendar` (Python) or `ics` (Node)\n- Output `.ics`\n\n## Option C (if PDF is a scan/image): OCR → structured text → `.ics`\n**Tech stack**\n- macOS built-in OCR (Preview can copy text in many cases), or\n- `tesseract` via Homebrew for batch OCR, then parse text\n\n**Pros:** Works even for scans.  \n**Cons:** OCR errors; you’ll want a validation step.\n\n---\n\n# A working Mac script: text file → `.ics`\nIf you can get your schedule into a simple text format like:\n\n```\n2026-02-01 09:00-17:00\n2026-02-02 13:30-21:00\n2026-02-04 07:00-15:00\n```\n\nThis Python script will generate `Shifts.ics`.\n\n```python\nfrom datetime import datetime\nfrom icalendar import Calendar, Event\nimport uuid\n\ndef parse_line(line):\n    line = line.strip()\n    if not line:\n        return None\n    date_str, time_range = line.split()\n    start_str, end_str = time_range.split(\"-\")\n    start_dt = datetime.strptime(f\"{date_str} {start_str}\", \"%Y-%m-%d %H:%M\")\n    end_dt = datetime.strptime(f\"{date_str} {end_str}\", \"%Y-%m-%d %H:%M\")\n    return start_dt, end_dt\n\ncal = Calendar()\ncal.add(\"prodid\", \"-//Shift Calendar//example//\")\ncal.add(\"version\", \"2.0\")\n\nwith open(\"schedule.txt\", \"r\", encoding=\"utf-8\") as f:\n    for raw in f:\n        parsed = parse_line(raw)\n        if parsed is None:\n            continue\n        start_dt, end_dt = parsed\n        event = Event()\n        event.add(\"uid\", f\"{uuid.uuid4()}@shifts\")\n        event.add(\"summary\", \"Work Shift\")\n        event.add(\"dtstart\", start_dt)\n        event.add(\"dtend\", end_dt)\n        cal.add_component(event)\n\nwith open(\"Shifts.ics\", \"wb\") as out:\n    out.write(cal.to_ical())\n```\n\nInstall dependencies:\n\n```bash\npython3 -m pip install icalendar\n```\n\nThen run:\n\n```bash\npython3 make_ics.py\n```\n\nOpen `Shifts.ics` on your Mac and add it to your Calendar, or AirDrop it to iPhone and import.\n\n---\n\n# PDF → `.ics`: what’s feasible depends on the PDF\nTo answer your question directly: **yes, it’s possible**, but the approach changes based on the PDF type.\n\n## 1) “Real text” PDF (not scanned)\nYou can usually extract lines with times/dates using `pdfplumber`.\n\nInstall:\n\n```bash\npython3 -m pip install pdfplumber icalendar\n```\n\nA typical pipeline is:\n- extract all text\n- regex for date + start/end times\n- emit events\n\nWhether this is easy depends on how consistent the schedule formatting is.\n\n## 2) Scanned PDF/image\nUse OCR first (Preview or Tesseract), then treat it like Option B.\n\nInstall Tesseract:\n\n```bash\nbrew install tesseract\n```\n\nOCR to text:\n\n```bash\ntesseract schedule.pdf stdout -l eng\n```\n\nThen parse the output and generate the `.ics`.\n\n---\n\n# Shortcuts side (high-level)\nOnce the shifts are in a calendar on your iPhone:\n- Shortcut runs **daily** (for example at 6 PM) and:\n  - Finds tomorrow’s shift events in that calendar\n  - Creates an alarm for **event start - 30 minutes**\n  - Optionally avoids duplicates by checking existing alarms (Shortcuts can list alarms)\n\n---\n\n## Two details I need to give you a “works-first-try” solution\n1) Can you show an example of the schedule format (paste a few lines of text, or upload a screenshot/PDF page)?  \n2) Are your shifts ever overnight (start one day, end after midnight), and what time zone are you in?"
  },
  {
    "role": "user",
    "content": "We'll keep this simple. Shifts are never overnight, and they are presented in my local time zone, CST. I will copy and paste some text like this into a python program that should generate the ics file: \nMonday 01/26 \n\t\nKITCHEN - TM: Grill Master\n\t11:00 AM\t3:00 PM\t4\t\nTuesday 01/27 \n\t\nKITCHEN - TM: Grill Master\n\t11:00 AM\t5:00 PM\t5.5\t\n\t\nKITCHEN - TM: Grill Master\n\t5:00 PM\t8:00 PM\t2.5\t\nWednesday 01/28 \n\t\nFRONT - TM: Guest Attendant - Run\n\t4:00 PM\t8:00 PM\t4\t\nThursday 01/29 \n\t\nKITCHEN - TM: Fry Specialist\n\t11:00 AM\t3:00 PM\t4\t\n\t\nKITCHEN - TM: Fry Specialist\n\t5:00 PM\t8:00 PM\t3\t\nSaturday 01/31 \n\t\nKITCHEN - TM: Fry Specialist\n\t11:00 AM\t3:00 PM\t3.5\t\n\t\nKITCHEN - TM: Grill Master\n\t3:00 PM\t8:00 PM\t4.5"
  },
  {
    "role": "assistant",
    "content": "Here’s a simple Python tech stack for your exact pasted format:\n\n- **Python 3**\n- Standard library only (no dependencies)\n- Parse the pasted block into:\n  - a current “day header” (like `Monday 01/26`)\n  - a current “role line” (like `KITCHEN - TM: Grill Master`)\n  - one or more time ranges under that role\n- Emit an `.ics` file with events in **local time** (floating times; Calendar will treat them as local)\n\n## Python script: paste text → `Shifts.ics`\n\nSave as `make_ics.py`:\n\n```python\nimport re\nimport uuid\nfrom datetime import datetime\n\nINPUT_TEXT = \"\"\"Monday 01/26 \n\t\nKITCHEN - TM: Grill Master\n\t11:00 AM\t3:00 PM\t4\t\nTuesday 01/27 \n\t\nKITCHEN - TM: Grill Master\n\t11:00 AM\t5:00 PM\t5.5\t\n\t\nKITCHEN - TM: Grill Master\n\t5:00 PM\t8:00 PM\t2.5\t\nWednesday 01/28 \n\t\nFRONT - TM: Guest Attendant - Run\n\t4:00 PM\t8:00 PM\t4\t\nThursday 01/29 \n\t\nKITCHEN - TM: Fry Specialist\n\t11:00 AM\t3:00 PM\t4\t\n\t\nKITCHEN - TM: Fry Specialist\n\t5:00 PM\t8:00 PM\t3\t\nSaturday 01/31 \n\t\nKITCHEN - TM: Fry Specialist\n\t11:00 AM\t3:00 PM\t3.5\t\n\t\nKITCHEN - TM: Grill Master\n\t3:00 PM\t8:00 PM\t4.5\n\"\"\"\n\nYEAR = 2026\nCALNAME = \"Work Shifts\"\nDEFAULT_TITLE = \"Work\"\n\nDAY_HEADER_RE = re.compile(r\"^\\s*(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday)\\s+(\\d{2})/(\\d{2})\\s*$\")\nTIME_RE = re.compile(r\"(\\d{1,2}:\\d{2}\\s*[AP]M)\", re.IGNORECASE)\n\ndef parse_time(s):\n    cleaned = re.sub(r\"\\s+\", \" \", s.strip().upper())\n    return datetime.strptime(cleaned, \"%I:%M %p\").time()\n\ndef format_dt(dt):\n    return dt.strftime(\"%Y%m%dT%H%M%S\")\n\ndef fold_ics_line(line):\n    out = []\n    while len(line) > 75:\n        out.append(line[:75])\n        line = \" \" + line[75:]\n    out.append(line)\n    return \"\\r\\n\".join(out)\n\ndef ics_escape(text):\n    text = text.replace(\"\\\\\", \"\\\\\\\\\")\n    text = text.replace(\"\\n\", \"\\\\n\")\n    text = text.replace(\";\", \"\\\\;\")\n    text = text.replace(\",\", \"\\\\,\")\n    return text\n\nlines = INPUT_TEXT.splitlines()\n\nevents = []\ncurrent_date = None\ncurrent_role = None\n\nfor raw in lines:\n    line = raw.strip()\n    if not line:\n        continue\n\n    m = DAY_HEADER_RE.match(line)\n    if m:\n        month = int(m.group(2))\n        day = int(m.group(3))\n        current_date = datetime(YEAR, month, day).date()\n        current_role = None\n        continue\n\n    if TIME_RE.search(line):\n        if current_date is None:\n            raise ValueError(f\"Found times before any day header: {line}\")\n        if current_role is None:\n            current_role = DEFAULT_TITLE\n\n        times = TIME_RE.findall(line)\n        if len(times) < 2:\n            raise ValueError(f\"Could not find start and end times in: {line}\")\n\n        start_t = parse_time(times[0])\n        end_t = parse_time(times[1])\n\n        start_dt = datetime.combine(current_date, start_t)\n        end_dt = datetime.combine(current_date, end_t)\n\n        if end_dt <= start_dt:\n            raise ValueError(f\"End time must be after start time (no overnight). Line: {line}\")\n\n        events.append((start_dt, end_dt, current_role))\n        continue\n\n    if current_date is not None:\n        current_role = line\n\nnow_utc = datetime.utcnow().strftime(\"%Y%m%dT%H%M%SZ\")\n\nics_lines = []\nics_lines.append(\"BEGIN:VCALENDAR\")\nics_lines.append(\"VERSION:2.0\")\nics_lines.append(\"PRODID:-//Work Shift Generator//EN\")\nics_lines.append(\"CALSCALE:GREGORIAN\")\nics_lines.append(fold_ics_line(f\"X-WR-CALNAME:{ics_escape(CALNAME)}\"))\n\nfor start_dt, end_dt, role in events:\n    uid = f\"{uuid.uuid4()}@workshifts\"\n    summary = role.strip() if role.strip() else DEFAULT_TITLE\n    ics_lines.append(\"BEGIN:VEVENT\")\n    ics_lines.append(f\"UID:{uid}\")\n    ics_lines.append(f\"DTSTAMP:{now_utc}\")\n    ics_lines.append(f\"DTSTART:{format_dt(start_dt)}\")\n    ics_lines.append(f\"DTEND:{format_dt(end_dt)}\")\n    ics_lines.append(fold_ics_line(f\"SUMMARY:{ics_escape(summary)}\"))\n    ics_lines.append(\"END:VEVENT\")\n\nics_lines.append(\"END:VCALENDAR\")\n\nics_content = \"\\r\\n\".join(ics_lines) + \"\\r\\n\"\n\nwith open(\"Shifts.ics\", \"wb\") as f:\n    f.write(ics_content.encode(\"utf-8\"))\n\nprint(f\"Wrote Shifts.ics with {len(events)} event(s).\")\n```\n\nRun it:\n\n```bash\npython3 make_ics.py\n```\n\nIt will write `Shifts.ics` in the same folder.\n\n### Import to Calendar\n- Double-click `Shifts.ics` on your Mac to add it to Calendar, or\n- AirDrop `Shifts.ics` to your iPhone and open it to import.\n\n### Notes\n- This script uses “floating local time” (no timezone tag). Since your schedule is in CST and you’re using it locally, that’s usually what you want. If you travel across time zones and still want the alarms to stay anchored to CST, say so and I’ll adjust the generator to embed a `VTIMEZONE` and `TZID`.\n\nIf you tell me the year should always be “current year” (instead of hardcoding `YEAR = 2026`), I can adjust that too."
  },
  {
    "role": "user",
    "content": "Let's make it use the current year, and accept the text pasted as an argument from the console instead of hardcoding it."
  },
  {
    "role": "user",
    "content": "Here's my current code:\nimport re\nimport uuid\nfrom datetime import datetime\n\nINPUT_TEXT = \"\"\"Monday 01/26 \n\t\nKITCHEN - TM: Grill Master\n\t11:00 AM\t3:00 PM\t4\t\nTuesday 01/27 \n\t\nKITCHEN - TM: Grill Master\n\t11:00 AM\t5:00 PM\t5.5\t\n\t\nKITCHEN - TM: Grill Master\n\t5:00 PM\t8:00 PM\t2.5\t\nWednesday 01/28 \n\t\nFRONT - TM: Guest Attendant - Run\n\t4:00 PM\t8:00 PM\t4\t\nThursday 01/29 \n\t\nKITCHEN - TM: Fry Specialist\n\t11:00 AM\t3:00 PM\t4\t\n\t\nKITCHEN - TM: Fry Specialist\n\t5:00 PM\t8:00 PM\t3\t\nSaturday 01/31 \n\t\nKITCHEN - TM: Fry Specialist\n\t11:00 AM\t3:00 PM\t3.5\t\n\t\nKITCHEN - TM: Grill Master\n\t3:00 PM\t8:00 PM\t4.5\n\"\"\"\n\nYEAR = 2026\nCALNAME = \"Work Shifts\"\nDEFAULT_TITLE = \"Work\"\n\nDAY_HEADER_RE = re.compile(r\"^\\s*(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday)\\s+(\\d{2})/(\\d{2})\\s*$\")\nTIME_RE = re.compile(r\"(\\d{1,2}:\\d{2}\\s*[AP]M)\", re.IGNORECASE)\n\ndef parse_time(s):\n    cleaned = re.sub(r\"\\s+\", \" \", s.strip().upper())\n    return datetime.strptime(cleaned, \"%I:%M %p\").time()\n\ndef format_dt(dt):\n    return dt.strftime(\"%Y%m%dT%H%M%S\")\n\ndef fold_ics_line(line):\n    out = []\n    while len(line) > 75:\n        out.append(line[:75])\n        line = \" \" + line[75:]\n    out.append(line)\n    return \"\\r\\n\".join(out)\n\ndef ics_escape(text):\n    text = text.replace(\"\\\\\", \"\\\\\\\\\")\n    text = text.replace(\"\\n\", \"\\\\n\")\n    text = text.replace(\";\", \"\\\\;\")\n    text = text.replace(\",\", \"\\\\,\")\n    return text\n\nlines = INPUT_TEXT.splitlines()\n\nevents = []\ncurrent_date = None\ncurrent_role = None\n\nfor raw in lines:\n    line = raw.strip()\n    if not line:\n        continue\n\n    m = DAY_HEADER_RE.match(line)\n    if m:\n        month = int(m.group(2))\n        day = int(m.group(3))\n        current_date = datetime(YEAR, month, day).date()\n        current_role = None\n        continue\n\n    if TIME_RE.search(line):\n        if current_date is None:\n            raise ValueError(f\"Found times before any day header: {line}\")\n        if current_role is None:\n            current_role = DEFAULT_TITLE\n\n        times = TIME_RE.findall(line)\n        if len(times) < 2:\n            raise ValueError(f\"Could not find start and end times in: {line}\")\n\n        start_t = parse_time(times[0])\n        end_t = parse_time(times[1])\n\n        start_dt = datetime.combine(current_date, start_t)\n        end_dt = datetime.combine(current_date, end_t)\n\n        if end_dt <= start_dt:\n            raise ValueError(f\"End time must be after start time (no overnight). Line: {line}\")\n\n        events.append((start_dt, end_dt, current_role))\n        continue\n\n    if current_date is not None:\n        current_role = line\n\nnow_utc = datetime.utcnow().strftime(\"%Y%m%dT%H%M%SZ\")\n\nics_lines = []\nics_lines.append(\"BEGIN:VCALENDAR\")\nics_lines.append(\"VERSION:2.0\")\nics_lines.append(\"PRODID:-//Work Shift Generator//EN\")\nics_lines.append(\"CALSCALE:GREGORIAN\")\nics_lines.append(fold_ics_line(f\"X-WR-CALNAME:{ics_escape(CALNAME)}\"))\n\nfor start_dt, end_dt, role in events:\n    uid = f\"{uuid.uuid4()}@workshifts\"\n    summary = role.strip() if role.strip() else DEFAULT_TITLE\n    ics_lines.append(\"BEGIN:VEVENT\")\n    ics_lines.append(f\"UID:{uid}\")\n    ics_lines.append(f\"DTSTAMP:{now_utc}\")\n    ics_lines.append(f\"DTSTART:{format_dt(start_dt)}\")\n    ics_lines.append(f\"DTEND:{format_dt(end_dt)}\")\n    ics_lines.append(fold_ics_line(f\"SUMMARY:{ics_escape(summary)}\"))\n    ics_lines.append(\"END:VEVENT\")\n\nics_lines.append(\"END:VCALENDAR\")\n\nics_content = \"\\r\\n\".join(ics_lines) + \"\\r\\n\"\n\nwith open(\"Shifts.ics\", \"wb\") as f:\n    f.write(ics_content.encode(\"utf-8\"))\n\nprint(f\"Wrote Shifts.ics with {len(events)} event(s).\")\n"
  },
  {
    "role": "assistant",
    "content": "```python\nimport argparse\nimport re\nimport sys\nimport uuid\nfrom datetime import datetime\n\nCALNAME = \"Work Shifts\"\nDEFAULT_TITLE = \"Work\"\n\nDAY_HEADER_RE = re.compile(r\"^\\s*(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday)\\s+(\\d{2})/(\\d{2})\\s*$\")\nTIME_RE = re.compile(r\"(\\d{1,2}:\\d{2}\\s*[AP]M)\", re.IGNORECASE)\n\ndef parse_time(s):\n    cleaned = re.sub(r\"\\s+\", \" \", s.strip().upper())\n    return datetime.strptime(cleaned, \"%I:%M %p\").time()\n\ndef format_dt(dt):\n    return dt.strftime(\"%Y%m%dT%H%M%S\")\n\ndef fold_ics_line(line):\n    out = []\n    while len(line) > 75:\n        out.append(line[:75])\n        line = \" \" + line[75:]\n    out.append(line)\n    return \"\\r\\n\".join(out)\n\ndef ics_escape(text):\n    text = text.replace(\"\\\\\", \"\\\\\\\\\")\n    text = text.replace(\"\\n\", \"\\\\n\")\n    text = text.replace(\";\", \"\\\\;\")\n    text = text.replace(\",\", \"\\\\,\")\n    return text\n\ndef read_input_text(args):\n    if args.text is not None:\n        return args.text\n    if args.file is not None:\n        with open(args.file, \"r\", encoding=\"utf-8\") as f:\n            return f.read()\n    return sys.stdin.read()\n\ndef parse_events(input_text, year):\n    lines = input_text.splitlines()\n    events = []\n    current_date = None\n    current_role = None\n\n    for raw in lines:\n        line = raw.strip()\n        if not line:\n            continue\n\n        m = DAY_HEADER_RE.match(line)\n        if m:\n            month = int(m.group(2))\n            day = int(m.group(3))\n            current_date = datetime(year, month, day).date()\n            current_role = None\n            continue\n\n        if TIME_RE.search(line):\n            if current_date is None:\n                raise ValueError(f\"Found times before any day header: {line}\")\n            if current_role is None:\n                current_role = DEFAULT_TITLE\n\n            times = TIME_RE.findall(line)\n            if len(times) < 2:\n                raise ValueError(f\"Could not find start and end times in: {line}\")\n\n            start_t = parse_time(times[0])\n            end_t = parse_time(times[1])\n\n            start_dt = datetime.combine(current_date, start_t)\n            end_dt = datetime.combine(current_date, end_t)\n\n            if end_dt <= start_dt:\n                raise ValueError(f\"End time must be after start time (no overnight). Line: {line}\")\n\n            events.append((start_dt, end_dt, current_role))\n            continue\n\n        if current_date is not None:\n            current_role = line\n\n    return events\n\ndef build_ics(events, calname):\n    now_utc = datetime.utcnow().strftime(\"%Y%m%dT%H%M%SZ\")\n\n    ics_lines = []\n    ics_lines.append(\"BEGIN:VCALENDAR\")\n    ics_lines.append(\"VERSION:2.0\")\n    ics_lines.append(\"PRODID:-//Work Shift Generator//EN\")\n    ics_lines.append(\"CALSCALE:GREGORIAN\")\n    ics_lines.append(fold_ics_line(f\"X-WR-CALNAME:{ics_escape(calname)}\"))\n\n    for start_dt, end_dt, role in events:\n        uid = f\"{uuid.uuid4()}@workshifts\"\n        summary = role.strip() if role.strip() else DEFAULT_TITLE\n        ics_lines.append(\"BEGIN:VEVENT\")\n        ics_lines.append(f\"UID:{uid}\")\n        ics_lines.append(f\"DTSTAMP:{now_utc}\")\n        ics_lines.append(f\"DTSTART:{format_dt(start_dt)}\")\n        ics_lines.append(f\"DTEND:{format_dt(end_dt)}\")\n        ics_lines.append(fold_ics_line(f\"SUMMARY:{ics_escape(summary)}\"))\n        ics_lines.append(\"END:VEVENT\")\n\n    ics_lines.append(\"END:VCALENDAR\")\n    return \"\\r\\n\".join(ics_lines) + \"\\r\\n\"\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Generate an ICS file from pasted shift text.\")\n    parser.add_argument(\"-t\", \"--text\", help=\"Paste the shift text as a single argument.\")\n    parser.add_argument(\"-f\", \"--file\", help=\"Read shift text from a file.\")\n    parser.add_argument(\"-o\", \"--output\", default=\"Shifts.ics\", help=\"Output ICS filename.\")\n    parser.add_argument(\"--year\", type=int, default=datetime.now().year, help=\"Year for MM/DD entries (default: current year).\")\n    parser.add_argument(\"--calname\", default=CALNAME, help=\"Calendar name.\")\n    args = parser.parse_args()\n\n    input_text = read_input_text(args)\n    if not input_text.strip():\n        raise SystemExit(\"No input text provided. Use --text, --file, or pipe via stdin.\")\n\n    events = parse_events(input_text, args.year)\n    ics_content = build_ics(events, args.calname)\n\n    with open(args.output, \"wb\") as f:\n        f.write(ics_content.encode(\"utf-8\"))\n\n    print(f\"Wrote {args.output} with {len(events)} event(s).\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nUsage examples (pick one):\n\n```bash\npython3 make_ics.py --file schedule.txt\n```\n\n```bash\npbpaste | python3 make_ics.py\n```\n\n```bash\npython3 make_ics.py --text \"Monday 01/26\nKITCHEN - TM: Grill Master\n11:00 AM  3:00 PM  4\"\n```"
  },
  {
    "role": "user",
    "content": "This is great! But notice how sometimes 2 shifts are recorded, with one stopping at the exact time the next one ends. I don't want an alarm to go off in that case, because I will already be at work."
  },
  {
    "role": "user",
    "content": "Here's my current code:\nimport argparse\nimport re\nimport sys\nimport uuid\nfrom datetime import datetime\n\nCALNAME = \"Work Shifts\"\nDEFAULT_TITLE = \"Work\"\n\nDAY_HEADER_RE = re.compile(r\"^\\s*(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday)\\s+(\\d{2})/(\\d{2})\\s*$\")\nTIME_RE = re.compile(r\"(\\d{1,2}:\\d{2}\\s*[AP]M)\", re.IGNORECASE)\n\ndef parse_time(s):\n    cleaned = re.sub(r\"\\s+\", \" \", s.strip().upper())\n    return datetime.strptime(cleaned, \"%I:%M %p\").time()\n\ndef format_dt(dt):\n    return dt.strftime(\"%Y%m%dT%H%M%S\")\n\ndef fold_ics_line(line):\n    out = []\n    while len(line) > 75:\n        out.append(line[:75])\n        line = \" \" + line[75:]\n    out.append(line)\n    return \"\\r\\n\".join(out)\n\ndef ics_escape(text):\n    text = text.replace(\"\\\\\", \"\\\\\\\\\")\n    text = text.replace(\"\\n\", \"\\\\n\")\n    text = text.replace(\";\", \"\\\\;\")\n    text = text.replace(\",\", \"\\\\,\")\n    return text\n\ndef read_input_text(args):\n    if args.text is not None:\n        return args.text\n    if args.file is not None:\n        with open(args.file, \"r\", encoding=\"utf-8\") as f:\n            return f.read()\n    return sys.stdin.read()\n\ndef parse_events(input_text, year):\n    lines = input_text.splitlines()\n    events = []\n    current_date = None\n    current_role = None\n\n    for raw in lines:\n        line = raw.strip()\n        if not line:\n            continue\n\n        m = DAY_HEADER_RE.match(line)\n        if m:\n            month = int(m.group(2))\n            day = int(m.group(3))\n            current_date = datetime(year, month, day).date()\n            current_role = None\n            continue\n\n        if TIME_RE.search(line):\n            if current_date is None:\n                raise ValueError(f\"Found times before any day header: {line}\")\n            if current_role is None:\n                current_role = DEFAULT_TITLE\n\n            times = TIME_RE.findall(line)\n            if len(times) < 2:\n                raise ValueError(f\"Could not find start and end times in: {line}\")\n\n            start_t = parse_time(times[0])\n            end_t = parse_time(times[1])\n\n            start_dt = datetime.combine(current_date, start_t)\n            end_dt = datetime.combine(current_date, end_t)\n\n            if end_dt <= start_dt:\n                raise ValueError(f\"End time must be after start time (no overnight). Line: {line}\")\n\n            events.append((start_dt, end_dt, current_role))\n            continue\n\n        if current_date is not None:\n            current_role = line\n\n    return events\n\ndef build_ics(events, calname):\n    now_utc = datetime.utcnow().strftime(\"%Y%m%dT%H%M%SZ\")\n\n    ics_lines = []\n    ics_lines.append(\"BEGIN:VCALENDAR\")\n    ics_lines.append(\"VERSION:2.0\")\n    ics_lines.append(\"PRODID:-//Work Shift Generator//EN\")\n    ics_lines.append(\"CALSCALE:GREGORIAN\")\n    ics_lines.append(fold_ics_line(f\"X-WR-CALNAME:{ics_escape(calname)}\"))\n\n    for start_dt, end_dt, role in events:\n        uid = f\"{uuid.uuid4()}@workshifts\"\n        summary = role.strip() if role.strip() else DEFAULT_TITLE\n        ics_lines.append(\"BEGIN:VEVENT\")\n        ics_lines.append(f\"UID:{uid}\")\n        ics_lines.append(f\"DTSTAMP:{now_utc}\")\n        ics_lines.append(f\"DTSTART:{format_dt(start_dt)}\")\n        ics_lines.append(f\"DTEND:{format_dt(end_dt)}\")\n        ics_lines.append(fold_ics_line(f\"SUMMARY:{ics_escape(summary)}\"))\n        ics_lines.append(\"END:VEVENT\")\n\n    ics_lines.append(\"END:VCALENDAR\")\n    return \"\\r\\n\".join(ics_lines) + \"\\r\\n\"\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Generate an ICS file from pasted shift text.\")\n    parser.add_argument(\"-t\", \"--text\", help=\"Paste the shift text as a single argument.\")\n    parser.add_argument(\"-f\", \"--file\", help=\"Read shift text from a file.\")\n    parser.add_argument(\"-o\", \"--output\", default=\"Shifts.ics\", help=\"Output ICS filename.\")\n    parser.add_argument(\"--year\", type=int, default=datetime.now().year, help=\"Year for MM/DD entries (default: current year).\")\n    parser.add_argument(\"--calname\", default=CALNAME, help=\"Calendar name.\")\n    args = parser.parse_args()\n\n    input_text = read_input_text(args)\n    if not input_text.strip():\n        raise SystemExit(\"No input text provided. Use --text, --file, or pipe via stdin.\")\n\n    events = parse_events(input_text, args.year)\n    ics_content = build_ics(events, args.calname)\n\n    with open(args.output, \"wb\") as f:\n        f.write(ics_content.encode(\"utf-8\"))\n\n    print(f\"Wrote {args.output} with {len(events)} event(s).\")\n\nif __name__ == \"__main__\":\n    main()\n"
  },
  {
    "role": "assistant",
    "content": "The clean way to prevent that “mid-shift” alarm is to **merge contiguous shifts** (where the next shift starts exactly when the previous ends) into one longer event *before* generating the ICS. Then there’s only one start time for the whole block, so only one “30 minutes before” alarm will ever happen.\n\nBelow is your script updated to merge:\n- same-day events where `next.start_dt == current.end_dt`\n- and it also merges overlapping events (just in case)\n\nIt preserves the first role in the summary, and if roles differ it combines them like `Role A + Role B`.\n\n```python\nimport argparse\nimport re\nimport sys\nimport uuid\nfrom datetime import datetime\n\nCALNAME = \"Work Shifts\"\nDEFAULT_TITLE = \"Work\"\n\nDAY_HEADER_RE = re.compile(r\"^\\s*(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday)\\s+(\\d{2})/(\\d{2})\\s*$\")\nTIME_RE = re.compile(r\"(\\d{1,2}:\\d{2}\\s*[AP]M)\", re.IGNORECASE)\n\ndef parse_time(s):\n    cleaned = re.sub(r\"\\s+\", \" \", s.strip().upper())\n    return datetime.strptime(cleaned, \"%I:%M %p\").time()\n\ndef format_dt(dt):\n    return dt.strftime(\"%Y%m%dT%H%M%S\")\n\ndef fold_ics_line(line):\n    out = []\n    while len(line) > 75:\n        out.append(line[:75])\n        line = \" \" + line[75:]\n    out.append(line)\n    return \"\\r\\n\".join(out)\n\ndef ics_escape(text):\n    text = text.replace(\"\\\\\", \"\\\\\\\\\")\n    text = text.replace(\"\\n\", \"\\\\n\")\n    text = text.replace(\";\", \"\\\\;\")\n    text = text.replace(\",\", \"\\\\,\")\n    return text\n\ndef read_input_text(args):\n    if args.text is not None:\n        return args.text\n    if args.file is not None:\n        with open(args.file, \"r\", encoding=\"utf-8\") as f:\n            return f.read()\n    return sys.stdin.read()\n\ndef parse_events(input_text, year):\n    lines = input_text.splitlines()\n    events = []\n    current_date = None\n    current_role = None\n\n    for raw in lines:\n        line = raw.strip()\n        if not line:\n            continue\n\n        m = DAY_HEADER_RE.match(line)\n        if m:\n            month = int(m.group(2))\n            day = int(m.group(3))\n            current_date = datetime(year, month, day).date()\n            current_role = None\n            continue\n\n        if TIME_RE.search(line):\n            if current_date is None:\n                raise ValueError(f\"Found times before any day header: {line}\")\n            if current_role is None:\n                current_role = DEFAULT_TITLE\n\n            times = TIME_RE.findall(line)\n            if len(times) < 2:\n                raise ValueError(f\"Could not find start and end times in: {line}\")\n\n            start_t = parse_time(times[0])\n            end_t = parse_time(times[1])\n\n            start_dt = datetime.combine(current_date, start_t)\n            end_dt = datetime.combine(current_date, end_t)\n\n            if end_dt <= start_dt:\n                raise ValueError(f\"End time must be after start time (no overnight). Line: {line}\")\n\n            events.append((start_dt, end_dt, current_role))\n            continue\n\n        if current_date is not None:\n            current_role = line\n\n    return events\n\ndef merge_contiguous_events(events):\n    if not events:\n        return []\n\n    events_sorted = sorted(events, key=lambda e: (e[0], e[1], e[2]))\n    merged = []\n\n    cur_start, cur_end, cur_role = events_sorted[0]\n\n    for start_dt, end_dt, role in events_sorted[1:]:\n        same_day = start_dt.date() == cur_start.date()\n        overlaps_or_touches = start_dt <= cur_end\n\n        if same_day and overlaps_or_touches:\n            if end_dt > cur_end:\n                cur_end = end_dt\n            role_clean = role.strip() if role.strip() else DEFAULT_TITLE\n            cur_role_clean = cur_role.strip() if cur_role.strip() else DEFAULT_TITLE\n            if role_clean != cur_role_clean:\n                cur_role = f\"{cur_role_clean} + {role_clean}\"\n            else:\n                cur_role = cur_role_clean\n        else:\n            merged.append((cur_start, cur_end, cur_role))\n            cur_start, cur_end, cur_role = start_dt, end_dt, role\n\n    merged.append((cur_start, cur_end, cur_role))\n    return merged\n\ndef build_ics(events, calname):\n    now_utc = datetime.utcnow().strftime(\"%Y%m%dT%H%M%SZ\")\n\n    ics_lines = []\n    ics_lines.append(\"BEGIN:VCALENDAR\")\n    ics_lines.append(\"VERSION:2.0\")\n    ics_lines.append(\"PRODID:-//Work Shift Generator//EN\")\n    ics_lines.append(\"CALSCALE:GREGORIAN\")\n    ics_lines.append(fold_ics_line(f\"X-WR-CALNAME:{ics_escape(calname)}\"))\n\n    for start_dt, end_dt, role in events:\n        uid = f\"{uuid.uuid4()}@workshifts\"\n        summary = role.strip() if role.strip() else DEFAULT_TITLE\n        ics_lines.append(\"BEGIN:VEVENT\")\n        ics_lines.append(f\"UID:{uid}\")\n        ics_lines.append(f\"DTSTAMP:{now_utc}\")\n        ics_lines.append(f\"DTSTART:{format_dt(start_dt)}\")\n        ics_lines.append(f\"DTEND:{format_dt(end_dt)}\")\n        ics_lines.append(fold_ics_line(f\"SUMMARY:{ics_escape(summary)}\"))\n        ics_lines.append(\"END:VEVENT\")\n\n    ics_lines.append(\"END:VCALENDAR\")\n    return \"\\r\\n\".join(ics_lines) + \"\\r\\n\"\n\ndef main():\n    parser = argparse.ArgumentParser(description=\"Generate an ICS file from pasted shift text.\")\n    parser.add_argument(\"-t\", \"--text\", help=\"Paste the shift text as a single argument.\")\n    parser.add_argument(\"-f\", \"--file\", help=\"Read shift text from a file.\")\n    parser.add_argument(\"-o\", \"--output\", default=\"Shifts.ics\", help=\"Output ICS filename.\")\n    parser.add_argument(\"--year\", type=int, default=datetime.now().year, help=\"Year for MM/DD entries (default: current year).\")\n    parser.add_argument(\"--calname\", default=CALNAME, help=\"Calendar name.\")\n    args = parser.parse_args()\n\n    input_text = read_input_text(args)\n    if not input_text.strip():\n        raise SystemExit(\"No input text provided. Use --text, --file, or pipe via stdin.\")\n\n    events = parse_events(input_text, args.year)\n    events = merge_contiguous_events(events)\n    ics_content = build_ics(events, args.calname)\n\n    with open(args.output, \"wb\") as f:\n        f.write(ics_content.encode(\"utf-8\"))\n\n    print(f\"Wrote {args.output} with {len(events)} event(s).\")\n\nif __name__ == \"__main__\":\n    main()\n```\n\nIf you’d rather **keep the two events** in the calendar (for role accuracy) but still avoid the “second alarm,” the alternative is to *not merge events* and instead handle it in your **Shortcut** logic (only create an alarm for an event if it is not immediately preceded by another event ending at the same start time). If that’s your preference, tell me and I’ll outline the Shortcuts steps."
  },
  {
    "role": "user",
    "content": "This is just what I needed, thanks. Now, I have this imported to a calendar on my iPhone. How do I use shortcuts to put alarms 30 minutes before each shift?"
  },
  {
    "role": "assistant",
    "content": "1) **Create a dedicated Shift calendar**\n- On iPhone: Calendar app → Calendars → make sure your imported calendar is visible (or move the imported events into a dedicated “Work Shifts” calendar).\n\n2) **Create the Shortcut (“Make shift alarms”)**\nOpen **Shortcuts** → **+** → **Add Action** and build this flow:\n\n### A. Get upcoming shift events\n1. **Find Calendar Events**\n   - Filters:\n     - **Calendar**: your shift calendar (for example “Work Shifts”)\n     - **Start Date**: is in the next **2 days** (or 1 day if you prefer)\n   - Sort by: **Start Date**\n   - Limit: Off (or a reasonable number like 20)\n\n2. **Repeat with Each** (Calendar Events)\n\nInside the repeat, you’ll compute the alarm time and decide whether to create it.\n\n### B. For each event: compute “30 minutes before”\n3. **Get Details of Calendar Events** → **Start Date**\n4. **Adjust Date**\n   - Date: (Start Date)\n   - Subtract: **30 minutes**\n   - Output: AlarmTime\n\n### C. Avoid duplicates (so it doesn’t recreate the same alarm every day)\n5. **Find Alarms**\n   - Filter: **Label** is `Shift`\n   - (If you don’t see label filtering, just “Find Alarms” and filter with an If below.)\n\n6. **If** any existing alarm already matches AlarmTime\n   - Easiest practical method:\n     - **Format Date** (AlarmTime) to something like `h:mm a`\n     - Do the same formatting for each alarm time from Find Alarms\n     - If there’s a match, **skip**\n   - Otherwise, create it.\n\n### D. Create the alarm\n7. **Create Alarm**\n   - Time: **AlarmTime**\n   - Label: `Shift`\n   - Snooze: On/Off (your preference)\n\n8. (Optional) **Turn Alarm On** (some iOS versions create it already enabled, but adding “Turn Alarm On” makes it explicit)\n\nThat’s the core.\n\n---\n\n## A more robust “no duplicates” strategy (recommended)\nMatching solely on time can collide across days (11:30 AM today vs 11:30 AM tomorrow). To fix that, encode the **date + time** in the label.\n\n**Use this label format:**\n`Shift 2026-01-27 10:30`\n\nSteps change slightly:\n\n- After you compute `AlarmTime`:\n  1) **Format Date** (AlarmTime) as `yyyy-MM-dd HH:mm`\n  2) **Text** action: `Shift ${FormattedDate}`\n  3) Use that as the alarm label\n\nThen:\n- **Find Alarms**\n- **Repeat with Each Alarm**\n- **Get Details of Alarms → Label**\n- **If Label is exactly** `Shift 2026-01-27 10:30` → mark as “already exists”\n- Only create if not found\n\nThis makes it safe to run daily without duplicates.\n\n---\n\n## Make it automatic (Personal Automation)\nShortcuts → **Automation** → **+** → **Create Personal Automation**\n- Trigger: **Time of Day**\n- Time: pick something like **6:00 PM**\n- Repeat: **Daily**\n- Action: **Run Shortcut** → select “Make shift alarms”\n\nOn the final screen:\n- Turn off **Ask Before Running** (if available)\n- Turn off **Notify When Run** (optional)\n\nI suggest running it daily so tomorrow’s alarms are always ready even if you adjust/import the schedule late.\n\n---\n\n## Notes / gotchas\n- iOS alarms: Shortcuts can create alarms, but managing/updating them is clunkier than notifications. The label strategy above is the key to keeping it stable.\n- If you re-import the calendar and shift times change, you may want a second Shortcut that deletes alarms with label starting with `Shift ` for the affected date range, then recreates them.\n\nIf you tell me the **name of your shift calendar** and whether you want alarms created for **tomorrow only** or **next 7 days**, I can write the exact Shortcut action list in order (with the label format and duplicate-check logic)."
  }
]